/*Старая добрая игра на страницах всех школьных тетрадей. Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. 
Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита). 
Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает.
Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. 
Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.
Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). 
Это можно сделать сразу при объявлении либо с помощью вложенного цикла. 
На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, и игрок должен указать координаты клетки повторно. 
После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.

Действия для обоих игроков одинаковые, отличаются только символом, который ставится на поле. 
Игровой цикл не должен быть бесконечным. Игра имеет определённое максимальное количество шагов. Не забывайте про случай ничьей.
Как и в предыдущем задании, здесь будет удобно сразу заполнить массив значениями false. Количество мест, доступных для заполнения, заранее известно. 
В процессе заполнения из этой переменой нужно не забывать вычитать единицу. Чтобы отметить место как занятое, нужно лишь написать places[i][j] = true;.
Проверку на победу игрока, которую надо осуществлять после каждого хода, можно сделать с помощью вложенного цикла, сразу проверяя и вертикаль, и горизонталь, 
а как именно — попробуйте догадаться сами.
Здесь заранее известно число ходов — 3 * 3. Столько раз должен быть выполнен цикл, который спрашивает у очередного игрока координаты.
Символ, который будет установлен в указанных координатах, можно на каждом шаге менять подобным образом:
if (gamer_name == 'X') 
                gamer_name = 'O'; 
else 
                gamer_name = 'X';
*/

#include <iostream> 
#include <string>
#include <vector>
using namespace std;

char field[3][3] = { {'*', '*', '*'}, {'*', '*', '*'}, {'*', '*', '*'} }; // задать первоначальное поле пробелами

void printField() { // функция печати поля
    for (int i = 0; i < 3; i++) { // цикл для печати текущего состояния поля
        for (int j = 0; j < 3; j++) {
            cout << field[i][j];
        }
        cout << endl;
    }
    cout << endl;
}


int main() {
    printField();
    bool turn = true; // переменная для обозначения очередности хода. Если true, то ход игрока 1. Если false, то ход игрока 2
    int count = 9; // счетчик шагов
    do { // совершать цикл по печати поля и ввода игроком 
        int raw, column; // счетчик шагов
        cout << "Player " << turn << ", your turn. Input raw from 1 to 3: " << endl; // вывод сообщения о ходе игрока 1 и приглашение ввести № линии для воода
        cin >> raw;
        if (raw > 3 || raw < 1) { // проверка на корректность ввода номера строки
            cout << "Wrong raw number. Try again." << endl << endl;
            continue;
        }
        raw--;
        cout << "Player " << turn << ", your turn. Input column from 1 to 3: " << endl; // вывод сообщения о ходе игрока 1 и приглашение ввести № колонки для воода
        cin >> column;
        if (column > 3 || column < 1) { // проверка на корректность ввода номера столбца
            cout << "Wrong column number. Try again." << endl << endl;
            continue;
        }
        column--;
        if (field[raw][column] != '*') {  // проверка на незанятость клетки
            cout << "The cell is busy. Try again." << endl << endl;
            continue;
        }
        field[raw][column] = turn ? 'X' : 'O';
        printField();
        
        if ((field[0][0] == field[0][1] && field[0][0] == field[0][2] && field[0][0] != '*') || 
            (field[1][0] == field[1][1] && field[1][0] == field[1][2] && field[1][0] != '*') ||
            (field[2][0] == field[2][1] && field[2][0] == field[2][2] && field[2][0] != '*') || // проверка на равенство строк
            (field[0][0] == field[1][0] && field[0][0] == field[2][0] && field[0][0] != '*') ||
            (field[1][0] == field[1][1] && field[1][0] == field[1][2] && field[1][0] != '*') ||
            (field[2][0] == field[2][1] && field[2][0] == field[2][2] && field[2][0] != '*') || // проверка на равенство столбцов
            (field[0][0] == field[1][1] && field[0][0] == field[2][2] && field[0][0] != '*') ||
            (field[0][2] == field[1][1] && field[0][2] == field[2][0] && field[0][2] != '*')) { // проверка на равенство по диагонали
            cout << "Game over! Player " << turn << " won." << endl << endl;
            break;
            system("pause");
        }
        turn = !turn; // переменная становится false, ход переходит к игроку 2
        count--;
    } while (count != 0); // выполнять цикл, пока счетчик шагов не равен 0
    if (count == 0) cout << "It's a draw." << endl;
    system("pause");
}